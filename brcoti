#!/usr/bin/python3
#
# This is a simplistic build script for building artefacts of various
# programming languages natively (eg using pip, npm etc) and upload the
# resulting artefacts to a local repo.
#
#   Copyright (C) 2020 Olaf Kirch <okir@suse.de>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

import sys
import os
import os.path
import io
import pkginfo
import glob
import shutil
import brcoti_core

DEFAULT_BUILD_COMPUTE = "podman"

def create_build_engine(config):
	opts = config.command_line_options
	return brcoti_core.Engine.factory(opts.engine, config)

def create_compute_backend(config, default_backend):
	backend_name = config.command_line_options.compute or default_backend
	return brcoti_core.Compute.factory(backend_name, config)

def source_from_path(name, config):
	if os.path.isdir(name):
		print("=== Using source directory %s ===" % name)
		return brcoti_core.Engine.create_source_from_local_directory(name, config)

	engine = create_build_engine(config)

	print("=== Using file %s (build engine %s) ===" % (name, engine.name))
	source = engine.create_source_from_local_file(name)

	# DownloadFinder will never return an sdist that
	# requires a python version incompatible with ours.
	# For an sdist provided directly on the command line,
	# it might be nice to check for this explicitly, but that's a
	# lot of work. Not the least because many sdist tarballs
	# do not contain structured build information, but provide
	# a more or less messy setup.py

	return source

def find_source(engine, req_string, use_upstream = False, use_git = False):
	print("=== Locating %s in %s repository ===" % (req_string, use_upstream and "upstream" or "rebuild"))
	req = engine.parse_build_requirement(req_string)

	if not use_upstream:
		sdist = engine.build_source_locate(req)
	else:
		sdist = engine.build_source_locate_upstream(req)

	if sdist is None:
		print("FAILED to locate source for %s" % req)
		return None

	# By default, if the engine finds that a source artefact comes
	# with a git url, it will try to build directly from git.
	if not use_git:
		sdist.git_repo_url = None

	return brcoti_core.SourceFile(sdist, engine)

class BuildJob(object):
	def __init__(self, config, engine, compute_backend, source):
		self.config = config
		self.engine = engine
		self.compute_backend = compute_backend
		self.source = source
		self.build = None
		self.build_state = self.engine.build_state_factory(source)

		self.always_commit = False
		self.quiet = False
		self.rebuild_if_needed = False

	def id(self):
		return self.source.id()

	def rebuild_required(self):
		if not self.rebuild_if_needed:
			return True

		print("=== Checking whether a rebuild is required ===")
		if not self.build_state.rebuild_required():
			print("=== No rebuild required for %s ===" % self.id())
			return False

		return True

	def unpack_source(self):
		print("=== Unpacking %s ===" % self.id())
		build_info = self.source.info

		# Download the source archive if we don't have it yet
		for sdist in build_info.sources:
			# FIXME: how do we make sure we use the right downloader here? 
			if sdist.url and not sdist.git_url():
				self.engine.downloader.download(sdist)

		# spawn a container/VM or whatever compute node we need
		compute_node = self.engine.prepare_environment(self.compute_backend, build_info)

		self.build = self.engine.build_unpack(compute_node, build_info)

		self.build.set_logging(self.quiet, self.build_state.build_log_file())
		return self.build

	def build_package(self):
		print("=== Building %s ===" % self.id())
		build = self.build

		artefacts = build.build(self.source.info.build_script)

		if not artefacts:
			raise ValueError("%s: nothing got built" % self.source.id())

		return artefacts

	def process_build_dependencies(self):
		print("=== Inspecting build dependencies ===")
		build = self.build

		build.guess_build_dependencies()

		requires = self.engine.finalize_build_depdendencies(build)

		if requires:
			print("Build requirements:")
			for req in requires:
				print("  %-50s via %s" % (req.filename, req))

	def prepare_results(self):
		print("=== Collecting build results ===")
		build = self.build

		build.prepare_results(self.build_state)

	def compare_upstream(self):
		print("=== Comparing our build to upstream artefact(s) ===")
		engine = self.engine
		build = self.build

		import tempfile

		tmpdir = tempfile.TemporaryDirectory(prefix = "brcoti-")

		retval = True
		for mine in build.build_info.artefacts:
			req_string = "%s == %s" % (mine.name, mine.version)
			print("Trying to find upstream build for %s" % req_string)
			req = engine.parse_build_requirement(req_string)

			finder = engine.create_binary_download_finder(req, verbose = False)
			upstream = finder.get_best_match(engine.upstream_index)
			if not upstream:
				raise ValueError("No upstream build for %s" % req_string)

			engine.downloader.download(upstream, destdir = tmpdir.name)

			# This returns an ArtefactComparison object
			result = build.compare_build_artefacts(upstream.local_path, mine.local_path)

			if result:
				# Our build is identical with upstream
				continue

			print("%s differs from upstream build" % mine.id())
			result.print()

			print("--- showing diff ---")
			result.show_diff()
			print("--- end diff ---")
			print("")

			retval = False

		return retval

	def maybe_commit(self):
		print("=== Checking whether artefacts changed from previous build ===")
		build_state = self.build_state
		build = self.build

		if not self.always_commit and build.unchanged_from_previous_build(build_state):
			print("Artefacts have not changed since previous build")
			return

		uploader = self.engine.uploader
		if uploader:
			print("=== Uploading build results to %s ===" % uploader.describe())
			for p in build.artefacts:
				uploader.upload(p)

		build_state.commit()
		build.cleanup()

		build_state.cleanup()
		self.build_state = None

def prep_action(config, opts):
	engine = create_build_engine(config)
	compute_backend = create_compute_backend(config, "local")

	exit_code = 0
	for name in opts.packages:
		if os.path.isfile(name):
			source = source_from_path(name, config)
		else:
			source = find_source(engine, name, use_upstream = True, use_git = opts.git)
		if source is None:
			exit_code = 1
			continue

		sdist = source.info.sources[0]
		if sdist.url:
			print("Using %s" % (sdist.url))

		print("=== Package %s ===" %(source.id()))
		job = BuildJob(config, engine, compute_backend, source)
		job.quiet = opts.quiet

		try:
			job.unpack_source()
			job.build_package()
			job.process_build_dependencies()
			job.prepare_results()
			if opts.no_upstream_check:
				print("*** Skipping upstream check. ***")
			elif not job.compare_upstream():
				warnmsg = '''

        W   W    A    RRR  N   N II N   N  GGG   !!
        W   W   A A   R  R NN  N II NN  N G      !!
        W W W  AAAAA  RRR  N N N II N N N G  GG  !!
         W W  A     A R  R N  NN II N  NN  GGG   **

Our build seems to differ from the upstream build, which most likely means we did not
build it correctly.
If our build *IS* correct, and this warning is due to a bug, please fix the mis-detection.
If you're in a hurry, re-run this command with --no-upstream-check
'''
				print("=== WARNING: DIFFERS FROM UPSTREAM ===")
				print(warnmsg)
				print("=== WARNING: DIFFERS FROM UPSTREAM ===")
				exit_code = 1

			# job.maybe_commit()

		except Exception as e:
			print("FAILED to build %s" % sdist.id())
			import traceback
			print(e)
			traceback.print_tb(sys.exc_info()[2])
			traceback.format_exc()
			exit_code = 1

		write_source_dir(name, source.info, job.build.build_info)

	print("=== Done ===")
	return exit_code

def write_source_dir(name, source_info, build_info):
	src_dir = name
	if os.path.isdir(src_dir):
		shutil.rmtree(src_dir)
	os.makedirs(src_dir, mode = 0o755)
	for sdist in source_info.sources:
		shutil.copy(sdist.local_path, src_dir)

	info = source_info
	info.requires += build_info.requires

	info_path = os.path.join(src_dir, "build-info")
	info.save(info_path)

def submit_action(config, opts):
	exit_code = 0
	for name in opts.packages:
		print("Examining %s" % name)

		if not os.path.isdir(name):
			print("Cannot submit %s: must be a local directory" % name)
			exit_code = 1
			continue

		print("=== Using source directory %s ===" % name)
		source = brcoti_core.Engine.create_source_from_local_directory(name, config)

		engine = brcoti_core.Engine.factory(source.info.engine, config)
		if not engine:
			print("%s: build-info specifies invalid engine \"%s\"" % (name, source.info.engine))
			exit_code = 1
			break

		engine.submit_source(source)

	print("=== Done ===")
	return exit_code

def build_action(config, opts):
	compute_backend = create_compute_backend(config, DEFAULT_BUILD_COMPUTE)

	exit_code = 0
	for name in opts.packages:
		print("Examining %s" % name)

		source = source_from_path(name, config)
		if source is None:
			exit_code = 1
			continue

		engine = brcoti_core.Engine.factory(source.info.engine, config)

		print("=== Package %s ===" %(source.id()))
		job = BuildJob(config, engine, compute_backend, source)
		job.always_commit = opts.force
		job.quiet = opts.quiet
		job.rebuild_if_needed = opts.rebuild_if_needed

		try:
			if not job.rebuild_required():
				continue

			job.unpack_source()
			job.build_package()
			job.process_build_dependencies()
			job.prepare_results()

			if opts.upstream_check and not job.compare_upstream():
				warnmsg = '''

        W   W    A    RRR  N   N II N   N  GGG   !!
        W   W   A A   R  R NN  N II NN  N G      !!
        W W W  AAAAA  RRR  N N N II N N N G  GG  !!
         W W  A     A R  R N  NN II N  NN  GGG   **

Our build seems to differ from the upstream build, which most likely means we did not
build it correctly.
If our build *IS* correct, and this warning is due to a bug, please fix the mis-detection.
'''
				print("=== WARNING: DIFFERS FROM UPSTREAM ===")
				print(warnmsg)
				print("=== WARNING: DIFFERS FROM UPSTREAM ===")
				exit_code = 1

			job.maybe_commit()

		except Exception as e:
			print("FAILED to build %s" % source.id())
			import traceback
			print(e)
			traceback.print_tb(sys.exc_info()[2])
			traceback.format_exc()
			exit_code = 1

	print("=== Done ===")
	return exit_code

def mkindex_action(config, opts):
	engine = brcoti_core.Engine.factory(opts.engine, config)

	print("=== Publishing %s build results ===" % engine.name)
	engine.publish_build_results()

	print("=== Done ===")
	return 0

def build_option_parser():
	import argparse

	parser = argparse.ArgumentParser(prog = "minibuild",
		description = "Build artefacts for various native package managers")

	parser.add_argument('--config', default = [], action = 'append',
		help = "Path to configuration file")

	parser.add_argument('--engine', default = "python3",
		help = "Build engine to use (defaults to python3)")

	parser.add_argument('--debug', default = False, action = 'store_true',
                help = "Enable debugging output")
	parser.add_argument('--quiet', default = False, action = 'store_true',
                help = "Be less verbose")

	parser.add_argument('--compute', default = None,
		help = "Compute backend to use (default is dependent on the action)")

	subparsers = parser.add_subparsers(dest="action",
		title = "action")

	prep_parser = subparsers.add_parser('prep',
		help = "Prepare new source package")

	prep_parser.add_argument('packages', metavar = 'PKG', type = str, nargs = '+',
		help = "List of packages")
	prep_parser.add_argument('--git', default = False, action = 'store_true',
                help = "Build from git repo rather than sdist")
	prep_parser.add_argument('--no-upstream-check', default = False, action = 'store_true',
                help = "Do not compare our build results to upstream build (use with caution)")

	submit_parser = subparsers.add_parser('submit',
		help = "Submit source package(s)")
	submit_parser.add_argument('packages', metavar = 'PKG', type = str, nargs = '+',
		help = "List of packages")

	build_parser = subparsers.add_parser('build',
		help = "Build package(s)")
	build_parser.add_argument('packages', metavar = 'PKG', type = str, nargs = '+',
		help = "List of packages")
	build_parser.add_argument('--rebuild-if-needed', default = False, action = 'store_true',
                help = "Only rebuild package if needed")
	build_parser.add_argument('--force', default = False, action = 'store_true',
                help = "Always store build results, even if they did not change")
	build_parser.add_argument('--upstream-check', default = False, action = 'store_true',
                help = "Compare our build results to upstream build (use with caution)")

	mkindex_parser = subparsers.add_parser('make-index',
		help = "Rebuild package index")
	mkindex_parser.add_argument('--destdir', default = None,
		help = "Specify the destination directory (defaults to working directory)")

	return parser

opts = build_option_parser().parse_args()

config = brcoti_core.Config(opts)
config.load_file("/etc/pybuilder.json")
for config_path in opts.config:
	config.load_file(config_path)

if opts.action == 'prep':
	if not opts.packages:
		print("Nothing to be done.")
		exit(0)

	exit_code = prep_action(config, opts)
elif opts.action == 'submit':
	if not opts.packages:
		print("Nothing to be done.")
		exit(0)

	exit_code = submit_action(config, opts)
elif opts.action == 'build':
	if not opts.packages:
		print("Nothing to be done.")
		exit(0)

	exit_code = build_action(config, opts)
elif opts.action == 'make-index':
	exit_code = mkindex_action(config, opts)
else:
	raise NotImplementedError("Action %s not yet implemented" % opts.action)
exit(exit_code)
