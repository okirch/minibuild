#!/usr/bin/python3
#
# This is a simplistic build script for building artefacts of various
# programming languages natively (eg using pip, npm etc) and upload the
# resulting artefacts to a local repo.
#
#   Copyright (C) 2020 Olaf Kirch <okir@suse.de>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

import sys
import os
import os.path
import io
import pkginfo
import glob
import shutil
import brcoti_core

def build_option_parser():
	import optparse

	parser = optparse.OptionParser(usage = "blah")

	parser.add_option('--engine', default = "python",
		help = "Build engine to use (defaults to python)")

	parser.add_option('--debug', default = False, action = 'store_true',
                help = "Enable debugging output")
	parser.add_option('--quiet', default = False, action = 'store_true',
                help = "Be less verbose")
	parser.add_option('--git', default = False, action = 'store_true',
                help = "Build from git repo rather than sdist")
	parser.add_option('--rebuild-if-needed', default = False, action = 'store_true',
                help = "Only rebuild package if needed")
	parser.add_option('--force', default = False, action = 'store_true',
                help = "Always store build results, even if they did not change")

	parser.add_option('--output-dir', default = "OUTPUT",
		help = "Directory to write output files to (defaults to OUTPUT)")

	parser.add_option('--upload-to', default = None,
		help = "Repository to upload packages to")
	parser.add_option('--repo-user', default = None,
		help = "Repository user for uploading packages")
	parser.add_option('--repo-password', default = None,
		help = "Repository password for uploading packages")

	parser.add_option('--compute', default = 'podman',
		help = "Compute backend to use (default %(default)s)")

	return parser

(opts, args) = build_option_parser().parse_args()

if not args:
	print("Nothing to be done.")
	exit(0)

compute_backend = brcoti_core.Compute.factory(opts.compute, opts)

engine = brcoti_core.Engine.factory(compute_backend, opts.engine, opts)

engine.prepare_environment()

downloader = engine.downloader
uploader = engine.uploader

exit_code = 0
for file in args:
	print("Examining %s" % file)

	if os.path.isfile(file):
		sdist = engine.build_info_from_local_file(file)

		if not sdist.is_source:
			print("ERROR: cannot build %s - not a source distribution" % sdist.filename)
			continue

		# DownloadFinder will never return an sdist that
		# requires a python version incompatible with ours.
		# For an sdist provided directly on the command line,
		# it might be nice to check for this explicitly, but that's a
		# lot of work. Not the least because many sdist tarballs
		# do not contain structured build information, but provide
		# a more or less messy setup.py
	else:
		sdist = engine.build_source_locate(file)

		if sdist is None:
			print("FAILED to locate source for %s" % file)
			exit_code = 1
			continue

	print("=== Package %s ===" %(sdist.id()))
	try:
		build_state = engine.build_state_factory(sdist)

		if opts.rebuild_if_needed:
			print("=== Checking whether a rebuild is required ===")
			if not build_state.rebuild_required():
				print("=== No rebuild required for %s ===" %(sdist.id()))
				continue

		print("=== Unpacking %s ===" %(sdist.id()))
		if not sdist.local_path:
			downloader.download(sdist)

		build = engine.build_unpack(sdist)
		build.set_logging(opts.quiet, build_state.build_log_file())

		print("=== Building %s ===" %(sdist.id()))
		artefacts = build.build()

		if not artefacts:
			raise ValueError("%s: nothing got built" % file)

		print("=== Inspecting build dependencies ===")
		build.guess_build_dependencies()

		engine.finalize_build_depdendencies(build)

		if build.build_requires:
			print("Build requirements:")
			sys.stdout.write(build.build_requires_as_string())

		print("=== Storing build results ===")
		build.prepare_results(build_state)

		print("=== Checking whether artefacts changed from previous build ===")
		if not opts.force and build.unchanged_from_previous_build(build_state):
			print("%s artefacts have not changed since previous build" % sdist.id())
			continue

		if uploader:
			print("=== Uploading build results to %s ===" % uploader.describe())
			for p in artefacts:
				uploader.upload(p)

			build_state.commit()
			build.cleanup()
		else:
			print("=== Leaving build results in %s ===" % build.location)
			sys.stdout.write(build.build_artefacts_as_string())

		build_state.cleanup()

	except Exception as e:
		print("FAILED to build %s" % sdist.id())
		import traceback
		print(e)
		traceback.print_tb(sys.exc_info()[2])
		traceback.format_exc()
		exit_code = 1

print("=== Done ===")
exit(exit_code)
